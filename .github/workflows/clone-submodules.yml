name: Collect CTF Resources

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  # 允许手动触发工作流
  workflow_dispatch:
  # 每周一自动运行
  schedule:
    - cron: '0 0 * * 1'

jobs:
  clone-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          submodules: false

      - name: Setup directories
        run: |
          mkdir -p writeups
          mkdir -p wiki

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Add writeup repositories as submodules
        run: |
          # 从README.md提取writeup仓库链接并添加为子模块
          cat README.md | grep -A 100 "1. Writeups" | grep -B 100 "2. Wiki" | grep -E "(https://github.com|git@github.com)" | while read -r repo; do
            if [ ! -z "$repo" ]; then
              # 清理URL，确保格式正确
              repo=$(echo $repo | tr -d '\r' | tr -d '\n' | tr -d ' ')
              
              # 处理不同格式的URL
              if [[ "$repo" == git@github.com:* ]]; then
                # SSH格式: git@github.com:username/repo.git
                # 提取仓库名称
                repo_name=$(echo $repo | awk -F':' '{print $2}' | awk -F'/' '{print $NF}' | sed 's/.git$//')
                normalized_repo="$repo"
                # 确保以.git结尾
                if [[ ! "$normalized_repo" =~ \.git$ ]]; then
                  normalized_repo="${normalized_repo}.git"
                fi
              else
                # HTTPS格式: https://github.com/username/repo.git
                # 标准化URL格式，确保以.git结尾
                if [[ ! "$repo" =~ \.git$ ]]; then
                  normalized_repo="${repo}.git"
                else
                  normalized_repo="$repo"
                fi
                # 提取仓库名称（不带.git后缀）
                repo_name=$(echo $normalized_repo | awk -F'/' '{print $NF}' | sed 's/.git$//')
              fi
              
              echo "Adding $repo_name from $normalized_repo as submodule"
              
              # 检查子模块是否已存在（考虑不同URL格式）
              repo_without_git=$(echo $normalized_repo | sed 's/.git$//')
              if grep -q "$normalized_repo" .gitmodules 2>/dev/null || grep -q "$repo_without_git" .gitmodules 2>/dev/null; then
                echo "Submodule $repo_name already exists, skipping"
              else
                git submodule add --depth=1 $normalized_repo writeups/$repo_name || echo "Failed to add $repo_name, may already exist or invalid"
              fi
            fi
          done

      - name: Add wiki repositories as submodules
        run: |
          # 从README.md提取wiki仓库链接并添加为子模块
          cat README.md | grep -A 100 "2. Wiki" | grep -E "(https://github.com|git@github.com)" | while read -r repo; do
            if [ ! -z "$repo" ]; then
              # 清理URL，确保格式正确
              repo=$(echo $repo | tr -d '\r' | tr -d '\n' | tr -d ' ')
              
              # 处理不同格式的URL
              if [[ "$repo" == git@github.com:* ]]; then
                # SSH格式: git@github.com:username/repo.git
                # 提取仓库名称
                repo_name=$(echo $repo | awk -F':' '{print $2}' | awk -F'/' '{print $NF}' | sed 's/.git$//')
                normalized_repo="$repo"
                # 确保以.git结尾
                if [[ ! "$normalized_repo" =~ \.git$ ]]; then
                  normalized_repo="${normalized_repo}.git"
                fi
              else
                # HTTPS格式: https://github.com/username/repo.git
                # 标准化URL格式，确保以.git结尾
                if [[ ! "$repo" =~ \.git$ ]]; then
                  normalized_repo="${repo}.git"
                else
                  normalized_repo="$repo"
                fi
                # 提取仓库名称（不带.git后缀）
                repo_name=$(echo $normalized_repo | awk -F'/' '{print $NF}' | sed 's/.git$//')
              fi
              
              echo "Adding $repo_name from $normalized_repo as submodule"
              
              # 检查子模块是否已存在（考虑不同URL格式）
              repo_without_git=$(echo $normalized_repo | sed 's/.git$//')
              if grep -q "$normalized_repo" .gitmodules 2>/dev/null || grep -q "$repo_without_git" .gitmodules 2>/dev/null; then
                echo "Submodule $repo_name already exists, skipping"
              else
                git submodule add --depth=1 $normalized_repo wiki/$repo_name || echo "Failed to add $repo_name, may already exist or invalid"
              fi
            fi
          done
          
      - name: Initialize and update submodules
        run: |
          # 只初始化直接子模块，不递归更新
          git submodule update --init --depth=1
          
          # 对于每个子模块单独处理，避免递归错误
          git submodule foreach 'git submodule update --init --depth=1 || true'
          
      - name: Commit changes if any new submodules were added
        run: |
          # 显示子模块状态
          echo "Current submodule status:"
          git submodule status
          
          # 检查是否有.gitmodules文件
          if [ -f ".gitmodules" ]; then
            echo "Content of .gitmodules file:"
            cat .gitmodules
          else
            echo "Warning: .gitmodules file does not exist"
          fi
          
          # 提交更改
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Changes detected, committing..."
            git add .
            git commit -m "Add new submodules via GitHub Actions"
            git push || {
              echo "Failed to push changes, trying to pull first"
              git pull --rebase
              git push
            }
          else
            echo "No changes to commit"
          fi
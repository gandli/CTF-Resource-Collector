name: 收集

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  # 允许手动触发工作流
  workflow_dispatch:
  # 每周一自动运行
  schedule:
    - cron: "0 0 * * 1"

jobs:
  clone-repos:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: 检出仓库
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          submodules: false

      - name: 设置目录和配置Git
        run: |
          # 定义资源类型配置
          declare -A resource_configs=(
            ["wiki"]="1. Wiki 资源"
            ["writeups"]="2. Writeups 资源"
            ["tools"]="3. Tools 工具"
          )

          # 创建所有资源目录
          for dir in "${!resource_configs[@]}"; do
            mkdir -p "$dir"
            echo "已创建目录: $dir"
          done

          # 配置Git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: 处理仓库子模块
        run: |
          # 定义处理仓库链接的函数
          process_repo_url() {
            local repo="$1"
            local target_dir="$2"
            
            # 清理URL，确保格式正确，移除反引号和空白字符
            repo=$(echo "$repo" | tr -d '\r' | tr -d '\n' | tr -d ' ' | tr -d '`' | xargs)
            
            # 处理不同格式的URL
            if [[ "$repo" == git@github.com:* ]]; then
              # SSH格式: git@github.com:username/repo.git
              # 提取仓库名称
              repo_name=$(echo $repo | awk -F':' '{print $2}' | awk -F'/' '{print $NF}' | sed 's/.git$//')
              normalized_repo="$repo"
              # 确保以.git结尾
              if [[ ! "$normalized_repo" =~ \.git$ ]]; then
                normalized_repo="${normalized_repo}.git"
              fi
            else
              # HTTPS格式: https://github.com/username/repo.git
              # 标准化URL格式，确保以.git结尾
              if [[ ! "$repo" =~ \.git$ ]]; then
                normalized_repo="${repo}.git"
              else
                normalized_repo="$repo"
              fi
              # 提取仓库名称（不带.git后缀）
              repo_name=$(echo $normalized_repo | awk -F'/' '{print $NF}' | sed 's/.git$//')
            fi
            
            echo "正在添加 $repo_name 从 $normalized_repo 作为子模块到 $target_dir/ 目录"
            
            # 检查子模块是否已存在（考虑不同URL格式）
            repo_without_git=$(echo $normalized_repo | sed 's/.git$//')
            if grep -q "$normalized_repo" .gitmodules 2>/dev/null || grep -q "$repo_without_git" .gitmodules 2>/dev/null; then
              echo "子模块 $repo_name 已存在，跳过"
            else
              # 添加子模块时禁用递归，避免嵌套子模块问题
              echo "执行: git submodule add --depth=1 --no-recursive '$normalized_repo' '$target_dir/$repo_name'"
              
              # 确保目标目录存在
              mkdir -p "$target_dir"
              
              # 尝试添加子模块
              error_output=$(git submodule add --depth=1 --no-recursive '$normalized_repo' '$target_dir/$repo_name' 2>&1)
              add_result=$?
              
              if [ $add_result -ne 0 ]; then
                echo "添加 $repo_name 失败，错误信息:"
                echo "$error_output"
                
                # 检查是否是因为嵌套子模块问题导致的失败
                if [ -d "$target_dir/$repo_name" ] && [ -f "$target_dir/$repo_name/.gitmodules" ]; then
                  echo "警告: $repo_name 包含嵌套子模块，这可能导致问题"
                fi
                
                # 检查是否是因为子模块已存在
                if echo "$error_output" | grep -q "already exists"; then
                  echo "子模块 $repo_name 已存在，尝试更新"
                  git submodule update --init --depth=1 "$target_dir/$repo_name" || echo "更新子模块失败"
                fi
              else
                echo "成功添加子模块: $repo_name 到 $target_dir/"
              fi
            fi
          }

          # 定义资源类型配置
          declare -A resource_configs=(
            ["writeups"]="2. Writeups 资源"
            ["wiki"]="1. Wiki 资源"
            ["tools"]="3. Tools 工具"
          )

          # 处理每种资源类型
          for dir in "${!resource_configs[@]}"; do
            section_title="${resource_configs[$dir]}"
            echo "正在处理 $dir 仓库，对应标题: $section_title"
            
            # 从README.md提取仓库链接并添加为子模块
            echo "从README.md提取 $section_title 部分的仓库链接..."
            
            # 使用更可靠的方式提取仓库链接
            repo_links=$(awk -v section="$section_title" -v RS="##" '$0 ~ section {p=1; next} p && /^##/ {p=0} p' README.md | grep -o -E 'https://github.com[^` ]+|git@github.com:[^` ]+')
            
            # 如果上面的方法失败，尝试备用方法
            if [ -z "$repo_links" ]; then
              echo "使用备用方法提取仓库链接..."
              repo_links=$(cat README.md | grep -A 100 "$section_title" | grep -A 100 "\`\`\`" | grep -B 100 "\`\`\`" | grep -E "^(https://github.com|git@github.com)" | tr -d '`')
            fi
            
            # 如果是 tools 目录，手动添加 awesome-mcp-security 仓库
            if [ "$dir" = "tools" ]; then
              echo "为 tools 目录添加 awesome-mcp-security 仓库"
              if ! echo "$repo_links" | grep -q "awesome-mcp-security"; then
                repo_links="$repo_links\nhttps://github.com/Puliczek/awesome-mcp-security.git"
              fi
            fi
            
            # 清理链接，移除可能的反引号、回车符、换行符和空白字符
            repo_links=$(echo "$repo_links" | tr -d '\`' | tr -d '\r' | sed 's/^[ \t]*//;s/[ \t]*$//')
            
            # 显示找到的链接
            echo "找到以下仓库链接:"
            echo "$repo_links"
            
            # 处理每个仓库链接
            echo "$repo_links" | while read -r repo; do
              if [ ! -z "$repo" ]; then
                # 清理链接，确保没有反引号和多余空格
                repo=$(echo "$repo" | tr -d '`' | tr -d '\r' | tr -d '\n' | sed 's/^[ \t]*//;s/[ \t]*$//' | xargs)
                echo "处理仓库链接: $repo"
                # 特殊处理已知有嵌套子模块问题的仓库
                if [[ "$repo" == *"bl4de/ctf"* ]]; then
                  echo "特殊处理 bl4de/ctf 仓库，使用 --no-recursive 选项"
                  process_repo_url "$repo" "$dir"
                  # 如果添加成功，创建一个空的 .no-recursive 文件标记不要递归初始化
                  if [ -d "$dir/ctf" ]; then
                    touch "$dir/ctf/.no-recursive"
                    echo "已创建 .no-recursive 标记文件"
                  fi
                else
                  process_repo_url "$repo" "$dir"
                fi
              fi
            done
          done

      - name: 初始化和更新子模块
        run: |
          # 确保.gitmodules文件存在
          if [ ! -f ".gitmodules" ]; then
            echo "警告: .gitmodules 文件不存在，可能没有成功添加子模块"
          else
            echo ".gitmodules 文件内容:"
            cat .gitmodules
          fi

          # 强制初始化直接子模块，不递归更新
          echo "初始化直接子模块..."
          git submodule init
          git submodule update --depth=1

          # 检查是否有嵌套子模块，但不尝试初始化它们
          echo "检查嵌套子模块但不初始化它们"
          git submodule foreach 'if [ -f .gitmodules ]; then echo "发现嵌套子模块在 $(pwd) 但不会初始化"; fi'

          # 禁用递归子模块初始化，避免缺少URL的错误
          git config --global submodule.recurse false

          # 对于没有标记为 .no-recursive 的子模块，尝试安全地初始化其子模块
          echo "安全地初始化没有标记为 .no-recursive 的子模块的嵌套子模块"
          git submodule foreach '
            if [ ! -f .no-recursive ] && [ -f .gitmodules ]; then
              echo "尝试初始化 $(pwd) 的子模块"
              git submodule update --init --depth=1 || echo "初始化 $(pwd) 的子模块失败，但继续处理"
            fi
          '

          # 显示子模块状态
          echo "子模块状态:"
          git submodule status

      - name: 清理问题子模块
        run: |
          # 检查是否有问题子模块（缺少URL的子模块）
          echo "检查问题子模块..."
          problem_submodules=$(git config --file .gitmodules --get-regexp path | awk '{print $2}' | while read path; do
            if ! git config --file .gitmodules --get "submodule.$path.url" > /dev/null 2>&1; then
              echo "$path"
            fi
          done)

          # 如果有问题子模块，从.gitmodules中移除它们
          if [ ! -z "$problem_submodules" ]; then
            echo "发现以下问题子模块（缺少URL）:"
            echo "$problem_submodules"
            echo "从.gitmodules中移除这些问题子模块..."
            
            for path in $problem_submodules; do
              echo "移除问题子模块: $path"
              git config --file .gitmodules --remove-section "submodule.$path" || echo "无法移除 $path，可能已不存在"
              rm -rf "$path"
            done
          else
            echo "未发现问题子模块"
          fi

      - name: 提交新增的子模块更改
        run: |
          # 显示子模块状态
          echo "当前子模块状态:"
          git submodule status

          # 检查是否有.gitmodules文件
          if [ -f ".gitmodules" ]; then
            echo ".gitmodules 文件内容:"
            cat .gitmodules
          else
            echo "警告: .gitmodules 文件不存在，尝试强制创建"
            touch .gitmodules
          fi

          # 检查工作目录状态
          echo "Git 状态:"
          git status

          # 强制添加所有更改，包括子模块
          echo "添加所有更改到暂存区..."
          git add -A
          git add .gitmodules

          # 提交更改
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "检测到更改，正在提交..."
            git commit -m "通过 GitHub Actions 添加新的子模块并清理问题子模块"
            
            # 确保推送成功
            echo "推送更改到远程仓库..."
            git push || {
              echo "推送更改失败，尝试先拉取最新代码"
              git pull --rebase
              git push
            }
            
            echo "子模块更改已成功提交和推送"
          else
            echo "没有需要提交的更改"
          fi
